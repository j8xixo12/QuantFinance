#ifndef RNGENERATOR_HPP_
#define RNGENERATOR_HPP_

#include <vector>
#include <random>
#include <initializer_list>

template<typename T, template<typename TT> class Dist>

class RNGenerator {
    protected:
        Dist<T> dist;
        std::mt19937_64 eng;

    public:
        RNGenerator() = default;
        template <typename... Args> RNGenerator(Args... args)
        : dist (Dist<T>(args...)), eng(std::mt19937_64()) {
            // Hard-coded 
            std::random_device rd; 
            eng.seed(rd());
        }

        template<typename T2> RNGenerator(const std::initializer_list<T2>&
                                        initList)
        : dist(initList), eng(std::mt19937_64()) {
            // Hard-coded 
            std::random_device rd; 
            eng.seed(rd());
        }

        virtual T operator() () { 
            // STL-compatible function
            return dist(eng);
        }

        virtual ~RNGenerator() {}

        // // Template member function using template template parameter trick
        // Container<T, Alloc> RandomArray(std::size_t n) {
        //     Container<T, Alloc> result(n);
        //     // STL algorithm to assign values generated by a call to this->() 
        //     std::generate(std::begin(result), std::end(result), *this);
        //     return result;
        // }

        // Container<T, Alloc> RandomArrayII(std::size_t n) { 
        //     // Second approach
        //     Container<T, Alloc> result(n);
        //     // STL algorithm to assign values generated by a call to this->() 
        //     for (std::size_t i = 0; i < result.size(); ++i) {
        //         result[i] = (*this)();
        //     }
        //     return result;
        // }

        // void Randomise(std::size_t count, Container<T, Alloc>& con) { 
        //     // Assign random values to the first count elements of
        //     // container 'con'
        //     std::generate_n(std::begin(con), count, *this);
        // }

};

template<typename T, template<typename TT> class Dist>

class PolarMarsaglia : public RNGenerator<T, Dist> {
    public:
        template <typename... Args> PolarMarsaglia(Args... args)
        : RNGenerator<T, Dist>(args...) {}

        virtual T operator() () override {
            T u, v, S;

            do {
                u = 2.0 * this->dist(this->eng) - 1.0; 
                v = 2.0 * this->dist(this->eng) - 1.0; 
                S = u * u + v * v;
            } while (S > 1.0 || S <= 0.0);
            T fac = std::sqrt(-2.0 * std::log(S) / S);
            return u * fac;
        }      
        virtual ~PolarMarsaglia() {}
};
#endif // RNGENERATOR_HPP_